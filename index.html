<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>US Immigration Workflow - Google Sheets Integration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f5f7fa;
            overflow: hidden;
            height: 100vh;
        }

        /* Configuration Modal */
        .config-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .config-modal.hidden {
            display: none;
        }

        .config-content {
            background: white;
            border-radius: 12px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .config-title {
            font-size: 24px;
            font-weight: 700;
            color: #0066ff;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-description {
            color: #586069;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .config-field {
            margin-bottom: 20px;
        }

        .config-label {
            display: block;
            font-weight: 600;
            color: #24292e;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .config-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e4e8;
            border-radius: 6px;
            font-size: 14px;
            font-family: monospace;
        }

        .config-input:focus {
            outline: none;
            border-color: #0066ff;
        }

        .config-hint {
            font-size: 12px;
            color: #586069;
            margin-top: 6px;
            font-style: italic;
        }

        .config-buttons {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        .config-btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .config-btn.primary {
            background: #0066ff;
            color: white;
        }

        .config-btn.primary:hover {
            background: #0052cc;
        }

        .config-btn.secondary {
            background: #6c757d;
            color: white;
        }

        .config-btn.secondary:hover {
            background: #5a6268;
        }

        .error-message {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .success-message {
            background: #efe;
            border: 1px solid #cfc;
            color: #3c3;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 13px;
        }

        /* Top Navigation Bar */
        .top-nav {
            background: white;
            height: 60px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 1000;
            position: relative;
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: #0066ff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workflow-title {
            font-size: 16px;
            color: #24292e;
            padding-left: 20px;
            border-left: 2px solid #e1e4e8;
        }

        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #e6f2ff;
            border-radius: 6px;
            font-size: 12px;
            color: #0066ff;
            font-weight: 600;
        }

        .sync-status.syncing {
            background: #fff3cd;
            color: #856404;
        }

        .sync-status.error {
            background: #fee;
            color: #c33;
        }

        .nav-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-btn {
            padding: 8px 16px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background: white;
            color: #24292e;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-btn:hover {
            background: #f6f8fa;
            border-color: #d1d5da;
        }

        .nav-btn.primary {
            background: #0066ff;
            color: white;
            border-color: #0066ff;
        }

        .nav-btn.primary:hover {
            background: #0052cc;
            border-color: #0052cc;
        }

        .nav-btn.success {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .nav-btn.success:hover {
            background: #218838;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* Left Sidebar */
        .left-sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #e1e4e8;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s ease, width 0.3s ease;
            position: relative;
        }

        .left-sidebar.collapsed {
            margin-left: -280px;
            width: 0;
        }

        .sidebar-toggle {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 150;
        }

        .sidebar-toggle:hover {
            background: #f6f8fa;
            border-color: #0066ff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .sidebar-toggle.visible {
            display: flex;
        }

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid #e1e4e8;
            background: #f6f8fa;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: 600;
            color: #24292e;
            margin-bottom: 8px;
        }

        .filter-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .filter-btn {
            flex: 1;
            padding: 6px 10px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn.active {
            background: #0066ff;
            color: white;
            border-color: #0066ff;
        }

        .search-box {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            font-size: 13px;
            background: white;
        }

        .nodes-list {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .node-item {
            padding: 10px 12px;
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: #24292e;
        }

        .node-item:hover {
            background: #e6f2ff;
            border-color: #0066ff;
            transform: translateX(4px);
        }

        .node-item.active-in-list {
            background: #d4e3ff;
            border-color: #0066ff;
            font-weight: 600;
        }

        .node-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .node-count {
            margin-left: auto;
            background: #0066ff;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .section-header {
            padding: 12px 16px 8px 16px;
            font-size: 11px;
            font-weight: 700;
            color: #586069;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f9fafb;
            cursor: grab;
        }

        .canvas-container.grabbing {
            cursor: grabbing;
        }

        #canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            fill: none;
            stroke: #cbd5e0;
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .connection-line.active {
            stroke: #0066ff;
            stroke-width: 3;
            opacity: 1;
        }

        .connection-line.dimmed {
            opacity: 0.15;
        }

        /* Workflow Nodes */
        .workflow-node {
            position: absolute;
            width: 200px;
            min-height: 100px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: move;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .workflow-node:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            transform: translateY(-2px);
            z-index: 50;
        }

        .workflow-node.active {
            box-shadow: 0 0 0 3px #0066ff, 0 4px 16px rgba(0,102,255,0.3);
            z-index: 100;
        }

        .workflow-node.highlighted {
            opacity: 1;
            z-index: 50;
        }

        .workflow-node.dimmed {
            opacity: 0.3;
            z-index: 5;
        }

        .workflow-node.selected {
            animation: pulse 0.5s ease-in-out 3;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 4px 16px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 0 0 4px #ffc107, 0 4px 16px rgba(255,193,7,0.4); }
        }

        .node-header {
            padding: 12px;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            font-size: 24px;
            text-align: center;
            border-bottom: 1px solid #e1e4e8;
        }

        .node-header.client-type {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .node-header.service {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .node-body {
            padding: 12px;
        }

        .node-title {
            font-size: 13px;
            font-weight: 500;
            color: #24292e;
            line-height: 1.4;
            text-align: center;
        }

        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #0066ff;
            border: 3px solid white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .connection-point:hover {
            transform: scale(1.3);
            box-shadow: 0 3px 10px rgba(0,102,255,0.4);
        }

        .connection-point.input {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.output {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Enhanced Tooltip */
        #tooltip {
            position: fixed;
            background: white;
            border: 2px solid #0066ff;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            color: #24292e;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            max-width: 400px;
            max-height: 500px;
            overflow-y: auto;
        }

        #tooltip.show {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 700;
            color: #0066ff;
            margin-bottom: 8px;
            font-size: 14px;
            border-bottom: 2px solid #e1e4e8;
            padding-bottom: 6px;
        }

        .tooltip-section {
            margin-top: 10px;
        }

        .tooltip-section-title {
            font-weight: 600;
            color: #586069;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        .tooltip-services-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .tooltip-services-list li {
            padding: 4px 0;
            padding-left: 20px;
            position: relative;
            color: #24292e;
            font-size: 12px;
            line-height: 1.4;
        }

        .tooltip-services-list li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #28a745;
            font-weight: bold;
        }

        .tooltip-count {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .tooltip-hint {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e1e4e8;
            font-style: italic;
            opacity: 0.7;
            font-size: 11px;
            color: #586069;
        }

        /* Stats Panel */
        .stats-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            min-width: 200px;
            z-index: 100;
            cursor: move;
        }

        .stats-title {
            font-weight: 600;
            font-size: 14px;
            color: #24292e;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 13px;
        }

        .stat-label {
            color: #586069;
        }

        .stat-value {
            font-weight: 600;
            color: #0066ff;
            background: #e6f2ff;
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* Clear Selection Button */
        #clearSelectionBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
            transition: all 0.2s;
            z-index: 101;
        }

        #clearSelectionBtn:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 53, 69, 0.4);
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #e1e4e8;
            border-top-color: #0066ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: #586069;
            font-weight: 500;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            color: #24292e;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .zoom-btn:hover {
            background: #f6f8fa;
            border-color: #0066ff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
    </style>
</head>
<body>
    <!-- Configuration Modal -->
    <div class="config-modal" id="configModal">
        <div class="config-content">
            <div class="config-title">
                üîë Google Sheets API Configuration
            </div>
            <div class="config-description">
                To connect your workflow to Google Sheets, you'll need to provide your API credentials. 
                See the setup guide for detailed instructions.
            </div>
            
            <div id="configError" class="error-message" style="display: none;"></div>
            <div id="configSuccess" class="success-message" style="display: none;"></div>
            
            <div class="config-field">
                <label class="config-label">Google Sheets API Key</label>
                <input type="text" id="apiKeyInput" class="config-input" placeholder="AIzaSy...">
                <div class="config-hint">Get this from Google Cloud Console ‚Üí APIs & Services ‚Üí Credentials</div>
            </div>
            
            <div class="config-field">
                <label class="config-label">Spreadsheet ID</label>
                <input type="text" id="spreadsheetIdInput" class="config-input" 
                       value="1WM_xGzj2KnBh1e8TRjnZD4BpxT13DHA8eiHgHwaznH8">
                <div class="config-hint">From your Google Sheets URL</div>
            </div>
            
            <div class="config-field">
                <label class="config-label">Sheet Names (comma-separated)</label>
                <input type="text" id="sheetNamesInput" class="config-input" 
                       value="Client Types,Services,Service Mappings"
                       placeholder="Client Types,Services,Service Mappings">
                <div class="config-hint">The names of the tabs in your spreadsheet</div>
            </div>
            
            <div class="config-buttons">
                <button class="config-btn secondary" onclick="useSampleData()">Use Sample Data</button>
                <button class="config-btn primary" onclick="saveConfiguration()">Connect & Load Data</button>
            </div>
        </div>
    </div>

    <!-- Top Navigation -->
    <div class="top-nav">
        <div class="nav-left">
            <div class="logo">
                <span>‚öñÔ∏è</span>
                Immigration Workflow
            </div>
            <div class="workflow-title">Google Sheets Integration</div>
            <div class="sync-status" id="syncStatus">
                <span>‚óè</span>
                <span id="syncStatusText">Not Connected</span>
            </div>
        </div>
        <div class="nav-right">
            <button class="nav-btn" onclick="showConfigModal()">‚öôÔ∏è Settings</button>
            <button class="nav-btn success" onclick="syncFromSheet()" id="syncBtn">üîÑ Sync from Sheet</button>
            <button class="nav-btn" onclick="focusClient()">üîç Find Client</button>
            <button class="nav-btn" onclick="autoLayout()">üìê Auto Layout</button>
            <button class="nav-btn" onclick="resetView()">üîÑ Reset View</button>
            <button class="nav-btn" onclick="exportWorkflow()">üíæ Export JSON</button>
            <button class="nav-btn primary" onclick="exportToSheet()">üì§ Export to Sheet Format</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Sidebar -->
        <div class="left-sidebar" id="leftSidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Nodes</div>
                <div class="filter-group">
                    <button class="filter-btn active" onclick="filterNodes('all')">All</button>
                    <button class="filter-btn" onclick="filterNodes('clients')">Clients</button>
                    <button class="filter-btn" onclick="filterNodes('services')">Services</button>
                </div>
                <input type="text" id="searchNodes" class="search-box" placeholder="Search nodes..." oninput="searchNodes()">
            </div>
            <div class="nodes-list" id="nodesList"></div>
        </div>

        <!-- Toggle sidebar button -->
        <div class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">
            ‚ò∞
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container" id="canvasContainer">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
                <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">‚óé</button>
                <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button>
            </div>
            
            <button id="clearSelectionBtn" onclick="clearActiveSelection()">
                ‚úï Clear Selection
            </button>
            
            <div id="canvas">
                <svg class="connection-svg" id="svg"></svg>
            </div>

            <!-- Stats Panel -->
            <div class="stats-panel" id="statsPanel">
                <div class="stats-title">üìä Statistics</div>
                <div class="stats-content">
                    <div class="stat-row">
                        <span class="stat-label">Total Connections:</span>
                        <span class="stat-value" id="connectionCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg Services/Client:</span>
                        <span class="stat-value" id="avgServices">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Tooltip -->
    <div id="tooltip"></div>

    <!-- Loading Screen -->
    <div id="loading" style="display: none;">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Loading...</div>
    </div>

    <script>
        // Configuration
        let config = {
            apiKey: localStorage.getItem('sheets_api_key') || '',
            spreadsheetId: localStorage.getItem('sheets_spreadsheet_id') || '1WM_xGzj2KnBh1e8TRjnZD4BpxT13DHA8eiHgHwaznH8',
            sheetNames: {
                clientTypes: 'Client Types',
                services: 'Services',
                mappings: 'Service Mappings'
            }
        };

        // Sample/Default Data (fallback)
        const defaultClientTypes = [
            { name: "Individual (Self-Petitioner)", emoji: "üë§" },
            { name: "Family-Based Petitioner", emoji: "üë®‚Äçüë©‚Äçüëß‚Äçüë¶" },
            { name: "Family-Based Beneficiary", emoji: "üë®‚Äçüë©‚Äçüëß" },
            { name: "Derivative Beneficiary", emoji: "üë∂" },
            { name: "Fianc√©(e) / Spouse Applicant", emoji: "üíë" }
        ];

        const defaultServices = [
            { name: "Initial Consultation & Case Evaluation", emoji: "üîç" },
            { name: "Legal Representation & Court Appearances", emoji: "‚öñÔ∏è" },
            { name: "Document Preparation & Review", emoji: "üìÑ" },
            { name: "Immigration Forms Filing", emoji: "üìã" },
            { name: "Green Card Application Processing", emoji: "üí≥" }
        ];

        const defaultMappings = [
            { clientType: "Individual (Self-Petitioner)", serviceName: "Initial Consultation & Case Evaluation" },
            { clientType: "Individual (Self-Petitioner)", serviceName: "Legal Representation & Court Appearances" },
            { clientType: "Individual (Self-Petitioner)", serviceName: "Document Preparation & Review" },
            { clientType: "Family-Based Petitioner", serviceName: "Initial Consultation & Case Evaluation" },
            { clientType: "Family-Based Petitioner", serviceName: "Family Petition Support" }
        ];

        // State
        let clientTypes = [];
        let services = [];
        let serviceMapping = {};
        let clientEmojis = {};
        let serviceEmojis = {};
        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let panOffset = { x: 0, y: 0 };
        let zoomLevel = 1;
        let activeNode = null;
        let currentHoveredNode = null;

        const canvas = document.getElementById('canvas');
        const svg = document.getElementById('svg');

        // Initialize
        window.addEventListener('load', () => {
            if (!config.apiKey) {
                showConfigModal();
            } else {
                init();
            }
        });

        // Show/Hide Configuration Modal
        function showConfigModal() {
            document.getElementById('configModal').classList.remove('hidden');
            document.getElementById('apiKeyInput').value = config.apiKey;
            document.getElementById('spreadsheetIdInput').value = config.spreadsheetId;
        }

        function hideConfigModal() {
            document.getElementById('configModal').classList.add('hidden');
        }

        // Save Configuration
        function saveConfiguration() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            const spreadsheetId = document.getElementById('spreadsheetIdInput').value.trim();
            const sheetNames = document.getElementById('sheetNamesInput').value.trim();

            if (!apiKey || !spreadsheetId) {
                showConfigError('Please provide both API Key and Spreadsheet ID');
                return;
            }

            // Parse sheet names
            const names = sheetNames.split(',').map(s => s.trim());
            if (names.length !== 3) {
                showConfigError('Please provide exactly 3 sheet names separated by commas');
                return;
            }

            config.apiKey = apiKey;
            config.spreadsheetId = spreadsheetId;
            config.sheetNames = {
                clientTypes: names[0],
                services: names[1],
                mappings: names[2]
            };

            localStorage.setItem('sheets_api_key', apiKey);
            localStorage.setItem('sheets_spreadsheet_id', spreadsheetId);

            showConfigSuccess('Configuration saved! Loading data...');
            
            setTimeout(() => {
                hideConfigModal();
                init();
            }, 1000);
        }

        function useSampleData() {
            loadSampleData();
            hideConfigModal();
            updateSyncStatus('Using Sample Data', 'synced');
        }

        function showConfigError(message) {
            const errorDiv = document.getElementById('configError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showConfigSuccess(message) {
            const successDiv = document.getElementById('configSuccess');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 3000);
        }

        // Update Sync Status
        function updateSyncStatus(text, status = 'synced') {
            const statusEl = document.getElementById('syncStatus');
            const textEl = document.getElementById('syncStatusText');
            
            textEl.textContent = text;
            statusEl.className = 'sync-status';
            
            if (status === 'syncing') {
                statusEl.classList.add('syncing');
            } else if (status === 'error') {
                statusEl.classList.add('error');
            }
        }

        // Load data from Google Sheets
        async function syncFromSheet() {
            if (!config.apiKey) {
                showConfigModal();
                return;
            }

            updateSyncStatus('Syncing...', 'syncing');
            showLoading('Fetching data from Google Sheets...');

            try {
                // Fetch Client Types
                const clientTypesData = await fetchSheetData(config.sheetNames.clientTypes);
                const servicesData = await fetchSheetData(config.sheetNames.services);
                const mappingsData = await fetchSheetData(config.sheetNames.mappings);

                // Process data
                processSheetData(clientTypesData, servicesData, mappingsData);

                updateSyncStatus('Synced with Google Sheets', 'synced');
                hideLoading();
                
                // Rebuild workflow
                rebuildWorkflow();
                
            } catch (error) {
                console.error('Sync error:', error);
                updateSyncStatus('Sync Failed - ' + error.message, 'error');
                hideLoading();
                
                // Load sample data as fallback
                if (confirm('Failed to load from Google Sheets. Use sample data instead?')) {
                    loadSampleData();
                    rebuildWorkflow();
                }
            }
        }

        // Fetch data from a specific sheet
        async function fetchSheetData(sheetName) {
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${config.spreadsheetId}/values/${encodeURIComponent(sheetName)}?key=${config.apiKey}`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'Failed to fetch sheet data');
            }
            
            const data = await response.json();
            return data.values || [];
        }

        // Process sheet data into workflow format
        function processSheetData(clientTypesData, servicesData, mappingsData) {
            // Clear existing data
            clientTypes = [];
            services = [];
            serviceMapping = {};
            clientEmojis = {};
            serviceEmojis = {};

            // Process Client Types (skip header row)
            for (let i = 1; i < clientTypesData.length; i++) {
                const row = clientTypesData[i];
                if (row[0]) {
                    const clientName = row[0].trim();
                    const emoji = row[1] || 'üë§';
                    clientTypes.push(clientName);
                    clientEmojis[clientName] = emoji;
                }
            }

            // Process Services (skip header row)
            for (let i = 1; i < servicesData.length; i++) {
                const row = servicesData[i];
                if (row[0]) {
                    const serviceName = row[0].trim();
                    const emoji = row[1] || '‚öôÔ∏è';
                    services.push(serviceName);
                    serviceEmojis[serviceName] = emoji;
                }
            }

            // Process Mappings (skip header row)
            for (let i = 1; i < mappingsData.length; i++) {
                const row = mappingsData[i];
                if (row[0] && row[1]) {
                    const clientName = row[0].trim();
                    const serviceName = row[1].trim();
                    
                    if (!serviceMapping[clientName]) {
                        serviceMapping[clientName] = [];
                    }
                    
                    const serviceIndex = services.indexOf(serviceName);
                    if (serviceIndex >= 0 && !serviceMapping[clientName].includes(serviceIndex)) {
                        serviceMapping[clientName].push(serviceIndex);
                    }
                }
            }

            console.log('Processed data:', { clientTypes, services, serviceMapping });
        }

        // Load sample data
        function loadSampleData() {
            clientTypes = defaultClientTypes.map(c => c.name);
            services = defaultServices.map(s => s.name);
            
            clientEmojis = {};
            defaultClientTypes.forEach(c => {
                clientEmojis[c.name] = c.emoji;
            });
            
            serviceEmojis = {};
            defaultServices.forEach(s => {
                serviceEmojis[s.name] = s.emoji;
            });
            
            serviceMapping = {};
            defaultMappings.forEach(m => {
                if (!serviceMapping[m.clientType]) {
                    serviceMapping[m.clientType] = [];
                }
                const serviceIndex = services.indexOf(m.serviceName);
                if (serviceIndex >= 0) {
                    serviceMapping[m.clientType].push(serviceIndex);
                }
            });
        }

        // Export data in sheet format
        function exportToSheet() {
            const output = {
                clientTypes: [],
                services: [],
                mappings: []
            };

            // Export client types
            output.clientTypes.push(['Client Type', 'Emoji']);
            clientTypes.forEach(client => {
                output.clientTypes.push([client, clientEmojis[client] || 'üë§']);
            });

            // Export services
            output.services.push(['Service Name', 'Emoji']);
            services.forEach(service => {
                output.services.push([service, serviceEmojis[service] || '‚öôÔ∏è']);
            });

            // Export mappings
            output.mappings.push(['Client Type', 'Service Name']);
            Object.keys(serviceMapping).forEach(client => {
                serviceMapping[client].forEach(serviceIndex => {
                    output.mappings.push([client, services[serviceIndex]]);
                });
            });

            // Create downloadable file
            const dataStr = JSON.stringify(output, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'sheet-data-export-' + new Date().toISOString().split('T')[0] + '.json';
            link.click();
            URL.revokeObjectURL(url);

            alert('Data exported!\n\nYou can:\n1. Copy this data to your Google Sheet\n2. Or import the JSON file into another system');
        }

        // Initialize workflow
        function init() {
            showLoading('Building workflow...');
            
            if (config.apiKey && !clientTypes.length) {
                syncFromSheet();
            } else if (!clientTypes.length) {
                loadSampleData();
                setTimeout(() => {
                    buildCompleteWorkflow();
                    populateNodesList();
                    setupStatsPanelDrag();
                    setupCanvasPanning();
                    hideLoading();
                }, 500);
            } else {
                setTimeout(() => {
                    buildCompleteWorkflow();
                    populateNodesList();
                    setupStatsPanelDrag();
                    setupCanvasPanning();
                    hideLoading();
                }, 500);
            }
        }

        // Rebuild workflow (when data changes)
        function rebuildWorkflow() {
            // Clear existing
            canvas.innerHTML = '<svg class="connection-svg" id="svg"></svg>';
            document.getElementById('nodesList').innerHTML = '';
            nodes = [];
            connections = [];
            nodeIdCounter = 0;
            activeNode = null;
            
            // Rebuild
            buildCompleteWorkflow();
            populateNodesList();
            updateStats();
        }

        // Build complete workflow with all mappings
        function buildCompleteWorkflow() {
            // Create client nodes in left column
            const clientStartX = 50;
            const clientStartY = 50;
            const clientSpacing = 120;

            clientTypes.forEach((client, index) => {
                const clientNode = createNode(
                    'client',
                    client,
                    clientStartX,
                    clientStartY + (index * clientSpacing)
                );
                clientNode.serviceCount = serviceMapping[client]?.length || 0;
            });

            // Create service nodes in right column
            const serviceStartX = 1200;
            const serviceStartY = 50;
            const serviceSpacing = 100;

            services.forEach((service, index) => {
                createNode(
                    'service',
                    service,
                    serviceStartX,
                    serviceStartY + (index * serviceSpacing)
                );
            });

            // Create all connections
            createAllConnections();
            
            // Update stats
            updateStats();
        }

        // Create node
        function createNode(type, name, x, y) {
            const nodeId = `node-${nodeIdCounter++}`;
            const node = {
                id: nodeId,
                type: type,
                name: name,
                x: x,
                y: y
            };

            const nodeElement = document.createElement('div');
            nodeElement.className = 'workflow-node';
            nodeElement.id = nodeId;
            
            const transformedX = x * zoomLevel + panOffset.x;
            const transformedY = y * zoomLevel + panOffset.y;
            nodeElement.style.transform = `translate(${transformedX}px, ${transformedY}px) scale(${zoomLevel})`;
            nodeElement.style.transformOrigin = '0 0';
            nodeElement.style.position = 'absolute';
            nodeElement.style.left = '0';
            nodeElement.style.top = '0';

            const headerClass = type === 'client' ? 'client-type' : 'service';
            let icon;
            
            if (type === 'client') {
                icon = clientEmojis[name] || 'üë§';
            } else {
                icon = serviceEmojis[name] || '‚öôÔ∏è';
            }

            nodeElement.innerHTML = `
                <div class="node-header ${headerClass}">
                    <span>${icon}</span>
                </div>
                <div class="node-body">
                    <div class="node-title">${name}</div>
                </div>
                <div class="connection-point input"></div>
                <div class="connection-point output"></div>
            `;

            nodeElement.addEventListener('mousedown', (e) => startDragNode(e, nodeId));
            nodeElement.addEventListener('mouseenter', (e) => {
                currentHoveredNode = nodeId;
                showEnhancedTooltip(e, node);
            });
            nodeElement.addEventListener('mouseleave', () => {
                currentHoveredNode = null;
                hideTooltip();
            });
            nodeElement.addEventListener('mousemove', (e) => {
                if (currentHoveredNode === nodeId) {
                    updateTooltipPosition(e);
                }
            });
            nodeElement.addEventListener('click', (e) => {
                if (!e.defaultPrevented) {
                    toggleNodeActivation(nodeId);
                }
            });

            canvas.appendChild(nodeElement);
            nodes.push(node);

            return node;
        }

        // Create all connections based on service mapping
        function createAllConnections() {
            clientTypes.forEach((client, clientIndex) => {
                const mappedServices = serviceMapping[client] || [];
                const clientNodeId = `node-${clientIndex}`;
                
                mappedServices.forEach(serviceIndex => {
                    const serviceNodeId = `node-${clientTypes.length + serviceIndex}`;
                    createConnection(clientNodeId, serviceNodeId);
                });
            });
        }

        // Create connection
        function createConnection(fromId, toId) {
            connections.push({ from: fromId, to: toId });
            drawConnection(fromId, toId);
        }

        // Draw connection line
        function drawConnection(fromId, toId) {
            const fromElement = document.getElementById(fromId);
            const toElement = document.getElementById(toId);
            
            if (!fromElement || !toElement) return;

            const fromData = nodes.find(n => n.id === fromId);
            const toData = nodes.find(n => n.id === toId);

            if (!fromData || !toData) return;

            const x1 = fromData.x * zoomLevel + panOffset.x + (200 * zoomLevel);
            const y1 = fromData.y * zoomLevel + panOffset.y + (50 * zoomLevel);
            const x2 = toData.x * zoomLevel + panOffset.x;
            const y2 = toData.y * zoomLevel + panOffset.y + (50 * zoomLevel);

            const path = createPath(x1, y1, x2, y2);
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            line.setAttribute('d', path);
            line.setAttribute('class', 'connection-line');
            line.setAttribute('data-from', fromId);
            line.setAttribute('data-to', toId);
            
            document.getElementById('svg').appendChild(line);
        }

        // Create smooth path
        function createPath(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const curve = Math.abs(dx) * 0.3;
            return `M ${x1} ${y1} C ${x1 + curve} ${y1}, ${x2 - curve} ${y2}, ${x2} ${y2}`;
        }

        // Redraw all connections
        function redrawConnections() {
            const svgEl = document.getElementById('svg');
            svgEl.innerHTML = '';
            connections.forEach(conn => {
                drawConnection(conn.from, conn.to);
            });
            
            // Reapply active/dimmed state if there's an active node
            if (activeNode) {
                const relatedConnections = connections.filter(conn => 
                    conn.from === activeNode || conn.to === activeNode
                );
                
                document.querySelectorAll('.connection-line').forEach(line => {
                    const from = line.getAttribute('data-from');
                    const to = line.getAttribute('data-to');
                    
                    if (from === activeNode || to === activeNode) {
                        line.classList.add('active');
                        line.classList.remove('dimmed');
                    } else {
                        line.classList.add('dimmed');
                        line.classList.remove('active');
                    }
                });
            }
        }

        // Toggle node activation
        function toggleNodeActivation(nodeId) {
            const clickedNode = document.getElementById(nodeId);
            
            if (clickedNode.dataset.justDragged === 'true') {
                return;
            }

            if (activeNode === nodeId) {
                deactivateAllNodes();
                activeNode = null;
                document.getElementById('clearSelectionBtn').style.display = 'none';
                updateSidebarActiveState(null);
                return;
            }

            activeNode = nodeId;
            document.getElementById('clearSelectionBtn').style.display = 'flex';
            
            const relatedConnections = connections.filter(conn => 
                conn.from === nodeId || conn.to === nodeId
            );
            
            const relatedNodeIds = new Set();
            relatedConnections.forEach(conn => {
                relatedNodeIds.add(conn.from);
                relatedNodeIds.add(conn.to);
            });

            document.querySelectorAll('.workflow-node').forEach(node => {
                if (relatedNodeIds.has(node.id)) {
                    node.classList.add('highlighted');
                    node.classList.remove('dimmed');
                } else {
                    node.classList.add('dimmed');
                    node.classList.remove('highlighted');
                }
            });

            clickedNode.classList.add('active');
            clickedNode.classList.remove('dimmed');

            document.querySelectorAll('.connection-line').forEach(line => {
                const from = line.getAttribute('data-from');
                const to = line.getAttribute('data-to');
                
                if (from === nodeId || to === nodeId) {
                    line.classList.add('active');
                    line.classList.remove('dimmed');
                } else {
                    line.classList.add('dimmed');
                    line.classList.remove('active');
                }
            });

            const activeCount = relatedConnections.length;
            const statsPanel = document.querySelector('.stats-panel');
            const existingInfo = statsPanel.querySelector('.active-info');
            
            if (existingInfo) {
                existingInfo.remove();
            }

            const nodeData = nodes.find(n => n.id === nodeId);
            const infoDiv = document.createElement('div');
            infoDiv.className = 'active-info';
            infoDiv.style.cssText = 'margin-top: 12px; padding-top: 12px; border-top: 2px solid #e9ecef; font-size: 12px; color: #28a745; font-weight: 600;';
            infoDiv.innerHTML = `
                <div style="margin-bottom: 6px;">üéØ Active: ${nodeData.name}</div>
                <div style="color: #586069; font-weight: normal;">${activeCount} connection${activeCount !== 1 ? 's' : ''}</div>
            `;
            
            document.querySelector('.stats-content').appendChild(infoDiv);
            updateSidebarActiveState(nodeId);
        }

        // Update sidebar to show active node
        function updateSidebarActiveState(nodeId) {
            document.querySelectorAll('.node-item').forEach(item => {
                item.classList.remove('active-in-list');
            });
            
            if (nodeId) {
                const nodeIndex = parseInt(nodeId.split('-')[1]);
                const sidebarItems = document.querySelectorAll('.node-item');
                if (sidebarItems[nodeIndex]) {
                    sidebarItems[nodeIndex].classList.add('active-in-list');
                }
            }
        }

        // Deactivate all nodes
        function deactivateAllNodes() {
            document.querySelectorAll('.workflow-node').forEach(node => {
                node.classList.remove('active', 'dimmed', 'highlighted');
            });

            document.querySelectorAll('.connection-line').forEach(line => {
                line.classList.remove('active', 'dimmed');
            });

            const existingInfo = document.querySelector('.active-info');
            if (existingInfo) {
                existingInfo.remove();
            }

            const clearBtn = document.getElementById('clearSelectionBtn');
            if (clearBtn) {
                clearBtn.style.display = 'none';
            }
        }

        function clearActiveSelection() {
            deactivateAllNodes();
            activeNode = null;
            updateSidebarActiveState(null);
        }

        // Start dragging node
        function startDragNode(e, nodeId) {
            if (e.target.closest('.connection-point')) return;

            let hasMoved = false;
            const node = document.getElementById(nodeId);
            const nodeData = nodes.find(n => n.id === nodeId);
            
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            const startNodeX = nodeData.x;
            const startNodeY = nodeData.y;

            function moveNode(e) {
                hasMoved = true;
                
                const dx = (e.clientX - startMouseX) / zoomLevel;
                const dy = (e.clientY - startMouseY) / zoomLevel;

                nodeData.x = startNodeX + dx;
                nodeData.y = startNodeY + dy;
                
                const transformedX = nodeData.x * zoomLevel + panOffset.x;
                const transformedY = nodeData.y * zoomLevel + panOffset.y;
                
                node.style.transform = `translate(${transformedX}px, ${transformedY}px) scale(${zoomLevel})`;
                node.style.transformOrigin = '0 0';

                redrawConnections();
            }

            function stopDrag(e) {
                document.removeEventListener('mousemove', moveNode);
                document.removeEventListener('mouseup', stopDrag);
                
                if (hasMoved) {
                    e.preventDefault();
                    setTimeout(() => {
                        node.dataset.justDragged = 'false';
                    }, 10);
                    node.dataset.justDragged = 'true';
                }
            }

            document.addEventListener('mousemove', moveNode);
            document.addEventListener('mouseup', stopDrag);
        }

        // Populate nodes list sidebar
        function populateNodesList() {
            const list = document.getElementById('nodesList');
            list.innerHTML = '';

            const clientHeader = document.createElement('div');
            clientHeader.className = 'section-header';
            clientHeader.textContent = 'CLIENT TYPES';
            list.appendChild(clientHeader);

            clientTypes.forEach((client, index) => {
                const count = serviceMapping[client]?.length || 0;
                const emoji = clientEmojis[client] || 'üë§';
                const item = document.createElement('div');
                item.className = 'node-item';
                item.dataset.type = 'client';
                item.innerHTML = `
                    <div class="node-icon">${emoji}</div>
                    <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${client}</div>
                    <div class="node-count">${count}</div>
                `;
                item.onclick = () => focusOnNode(`node-${index}`);
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    toggleNodeActivation(`node-${index}`);
                };
                item.title = "Left-click to focus, Right-click to activate";
                list.appendChild(item);
            });

            const serviceHeader = document.createElement('div');
            serviceHeader.className = 'section-header';
            serviceHeader.textContent = 'SERVICES';
            list.appendChild(serviceHeader);

            services.forEach((service, index) => {
                const emoji = serviceEmojis[service] || '‚öôÔ∏è';
                const item = document.createElement('div');
                item.className = 'node-item';
                item.dataset.type = 'service';
                item.innerHTML = `
                    <div class="node-icon">${emoji}</div>
                    <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${service}</div>
                `;
                item.onclick = () => focusOnNode(`node-${clientTypes.length + index}`);
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    toggleNodeActivation(`node-${clientTypes.length + index}`);
                };
                item.title = "Left-click to focus, Right-click to activate";
                list.appendChild(item);
            });
        }

        // Focus on specific node
        function focusOnNode(nodeId) {
            const nodeData = nodes.find(n => n.id === nodeId);
            if (!nodeData) return;

            const canvasRect = canvas.getBoundingClientRect();
            
            const centerX = canvasRect.width / 2;
            const centerY = canvasRect.height / 2;
            
            panOffset.x = centerX - (nodeData.x * zoomLevel) - (100 * zoomLevel);
            panOffset.y = centerY - (nodeData.y * zoomLevel) - (50 * zoomLevel);
            
            updateCanvasTransform();
            
            if (activeNode !== nodeId) {
                const node = document.getElementById(nodeId);
                document.querySelectorAll('.workflow-node').forEach(n => {
                    if (n.id === nodeId && !n.classList.contains('active')) {
                        n.classList.add('selected');
                    }
                });
                
                setTimeout(() => {
                    if (activeNode !== nodeId) {
                        node.classList.remove('selected');
                    }
                }, 2000);
            }
        }

        // Auto layout
        function autoLayout() {
            const clientSpacing = 120;
            const serviceSpacing = 100;
            
            clientTypes.forEach((client, index) => {
                const nodeId = `node-${index}`;
                const node = document.getElementById(nodeId);
                const nodeData = nodes.find(n => n.id === nodeId);
                
                nodeData.x = 50;
                nodeData.y = 50 + (index * clientSpacing);
                
                const transformedX = nodeData.x * zoomLevel + panOffset.x;
                const transformedY = nodeData.y * zoomLevel + panOffset.y;
                node.style.transform = `translate(${transformedX}px, ${transformedY}px) scale(${zoomLevel})`;
                node.style.transformOrigin = '0 0';
            });
            
            services.forEach((service, index) => {
                const nodeId = `node-${clientTypes.length + index}`;
                const node = document.getElementById(nodeId);
                const nodeData = nodes.find(n => n.id === nodeId);
                
                nodeData.x = 1200;
                nodeData.y = 50 + (index * serviceSpacing);
                
                const transformedX = nodeData.x * zoomLevel + panOffset.x;
                const transformedY = nodeData.y * zoomLevel + panOffset.y;
                node.style.transform = `translate(${transformedX}px, ${transformedY}px) scale(${zoomLevel})`;
                node.style.transformOrigin = '0 0';
            });
            
            redrawConnections();
            
            if (activeNode) {
                const relatedConnections = connections.filter(conn => 
                    conn.from === activeNode || conn.to === activeNode
                );
                
                const relatedNodeIds = new Set();
                relatedConnections.forEach(conn => {
                    relatedNodeIds.add(conn.from);
                    relatedNodeIds.add(conn.to);
                });
                
                document.querySelectorAll('.workflow-node').forEach(node => {
                    if (node.id === activeNode) {
                        node.classList.add('active');
                        node.classList.remove('dimmed', 'highlighted');
                    } else if (relatedNodeIds.has(node.id)) {
                        node.classList.add('highlighted');
                        node.classList.remove('dimmed', 'active');
                    } else {
                        node.classList.add('dimmed');
                        node.classList.remove('highlighted', 'active');
                    }
                });
            }
        }

        // Filter nodes in sidebar
        function filterNodes(filter) {
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const items = document.querySelectorAll('.node-item');
            const headers = document.querySelectorAll('.section-header');
            
            if (filter === 'all') {
                items.forEach(item => item.style.display = 'flex');
                headers.forEach(header => header.style.display = 'block');
            } else if (filter === 'clients') {
                items.forEach(item => {
                    item.style.display = item.dataset.type === 'client' ? 'flex' : 'none';
                });
                headers.forEach(header => {
                    if (header.textContent === 'CLIENT TYPES') {
                        header.style.display = 'block';
                    } else {
                        header.style.display = 'none';
                    }
                });
            } else if (filter === 'services') {
                items.forEach(item => {
                    item.style.display = item.dataset.type === 'service' ? 'flex' : 'none';
                });
                headers.forEach(header => {
                    if (header.textContent === 'SERVICES') {
                        header.style.display = 'block';
                    } else {
                        header.style.display = 'none';
                    }
                });
            }
        }

        // Search nodes
        function searchNodes() {
            const query = document.getElementById('searchNodes').value.toLowerCase();
            const items = document.querySelectorAll('.node-item');
            const headers = document.querySelectorAll('.section-header');
            
            let hasVisibleClients = false;
            let hasVisibleServices = false;
            
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                const isVisible = text.includes(query);
                item.style.display = isVisible ? 'flex' : 'none';
                
                if (isVisible) {
                    if (item.dataset.type === 'client') {
                        hasVisibleClients = true;
                    } else {
                        hasVisibleServices = true;
                    }
                }
            });
            
            headers.forEach(header => {
                if (header.textContent === 'CLIENT TYPES') {
                    header.style.display = hasVisibleClients ? 'block' : 'none';
                } else if (header.textContent === 'SERVICES') {
                    header.style.display = hasVisibleServices ? 'block' : 'none';
                }
            });
        }

        // Focus on a specific client
        function focusClient() {
            const clientName = prompt('Enter client type name to focus on:');
            if (!clientName) return;
            
            const index = clientTypes.findIndex(c => c.toLowerCase().includes(clientName.toLowerCase()));
            if (index >= 0) {
                focusOnNode(`node-${index}`);
            } else {
                alert('Client not found!');
            }
        }

        // Reset view
        function resetView() {
            panOffset = { x: 0, y: 0 };
            zoomLevel = 1;
            updateCanvasTransform();
            autoLayout();
            deactivateAllNodes();
            activeNode = null;
            updateSidebarActiveState(null);
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 3);
            updateCanvasTransform();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.3);
            updateCanvasTransform();
        }

        function resetZoom() {
            zoomLevel = 1;
            updateCanvasTransform();
        }

        // Update canvas transform
        function updateCanvasTransform() {
            const allNodes = canvas.querySelectorAll('.workflow-node');
            allNodes.forEach(node => {
                const nodeData = nodes.find(n => n.id === node.id);
                if (nodeData) {
                    const transformedX = nodeData.x * zoomLevel + panOffset.x;
                    const transformedY = nodeData.y * zoomLevel + panOffset.y;
                    node.style.transform = `translate(${transformedX}px, ${transformedY}px) scale(${zoomLevel})`;
                    node.style.transformOrigin = '0 0';
                }
            });
            
            redrawConnections();
            
            if (activeNode) {
                const relatedConnections = connections.filter(conn => 
                    conn.from === activeNode || conn.to === activeNode
                );
                
                const relatedNodeIds = new Set();
                relatedConnections.forEach(conn => {
                    relatedNodeIds.add(conn.from);
                    relatedNodeIds.add(conn.to);
                });
                
                document.querySelectorAll('.workflow-node').forEach(node => {
                    if (node.id === activeNode) {
                        node.classList.add('active');
                        node.classList.remove('dimmed', 'highlighted');
                    } else if (relatedNodeIds.has(node.id)) {
                        node.classList.add('highlighted');
                        node.classList.remove('dimmed', 'active');
                    } else {
                        node.classList.add('dimmed');
                        node.classList.remove('highlighted', 'active');
                    }
                });
            }
        }

        // Export workflow
        function exportWorkflow() {
            const workflow = {
                clientTypes: clientTypes,
                services: services,
                mappings: serviceMapping,
                nodes: nodes,
                connections: connections,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(workflow, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'immigration-workflow-' + new Date().toISOString().split('T')[0] + '.json';
            link.click();
            URL.revokeObjectURL(url);
        }

        // Update stats
        function updateStats() {
            const totalConnections = connections.length;
            const avgServices = clientTypes.length > 0 ? (totalConnections / clientTypes.length).toFixed(1) : 0;
            
            document.getElementById('connectionCount').textContent = totalConnections;
            document.getElementById('avgServices').textContent = avgServices;
        }

        // Enhanced tooltip with service mapping details
        function showEnhancedTooltip(e, node) {
            const tooltip = document.getElementById('tooltip');
            
            if (node.type === 'client') {
                const mappedServiceIndices = serviceMapping[node.name] || [];
                const serviceCount = mappedServiceIndices.length;
                
                let servicesHTML = '';
                mappedServiceIndices.forEach(serviceIndex => {
                    const serviceName = services[serviceIndex];
                    const serviceEmoji = serviceEmojis[serviceName] || '‚öôÔ∏è';
                    servicesHTML += `<li>${serviceEmoji} ${serviceName}</li>`;
                });
                
                tooltip.innerHTML = `
                    <div class="tooltip-title">${node.name}</div>
                    <div class="tooltip-section">
                        <div class="tooltip-section-title">
                            Recommended Services 
                            <span class="tooltip-count">${serviceCount}</span>
                        </div>
                        <ul class="tooltip-services-list">
                            ${servicesHTML}
                        </ul>
                    </div>
                    <div class="tooltip-hint">üí° Click to activate and highlight connections</div>
                `;
            } else {
                const clientsUsingService = Object.keys(serviceMapping).filter(client => {
                    const serviceIndex = services.indexOf(node.name);
                    return serviceMapping[client].includes(serviceIndex);
                });
                
                let clientsHTML = '';
                clientsUsingService.forEach(clientName => {
                    const clientEmoji = clientEmojis[clientName] || 'üë§';
                    clientsHTML += `<li>${clientEmoji} ${clientName}</li>`;
                });
                
                tooltip.innerHTML = `
                    <div class="tooltip-title">${node.name}</div>
                    <div class="tooltip-section">
                        <div class="tooltip-section-title">
                            Used by Clients 
                            <span class="tooltip-count">${clientsUsingService.length}</span>
                        </div>
                        <ul class="tooltip-services-list">
                            ${clientsHTML}
                        </ul>
                    </div>
                    <div class="tooltip-hint">üí° Click to activate and highlight connections</div>
                `;
            }
            
            updateTooltipPosition(e);
            tooltip.classList.add('show');
        }

        // Update tooltip position
        function updateTooltipPosition(e) {
            const tooltip = document.getElementById('tooltip');
            const offset = 15;
            let left = e.pageX + offset;
            let top = e.pageY + offset;
            
            const tooltipRect = tooltip.getBoundingClientRect();
            
            if (left + tooltipRect.width > window.innerWidth) {
                left = e.pageX - tooltipRect.width - offset;
            }
            
            if (top + tooltipRect.height > window.innerHeight) {
                top = e.pageY - tooltipRect.height - offset;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }

        // Toggle sidebar
        function toggleSidebar() {
            const sidebar = document.getElementById('leftSidebar');
            const toggle = document.getElementById('sidebarToggle');
            
            sidebar.classList.toggle('collapsed');
            toggle.classList.toggle('visible');
        }

        // Draggable stats panel
        function setupStatsPanelDrag() {
            const statsPanel = document.getElementById('statsPanel');
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            statsPanel.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                if (e.target === statsPanel || e.target.closest('.stats-title')) {
                    initialX = e.clientX - (statsPanel.offsetLeft || 0);
                    initialY = e.clientY - (statsPanel.offsetTop || 0);
                    isDragging = true;
                    statsPanel.style.cursor = 'grabbing';
                    statsPanel.style.transition = 'none';
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    setTranslate(currentX, currentY, statsPanel);
                }
            }

            function dragEnd(e) {
                if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    statsPanel.style.cursor = 'move';
                    statsPanel.style.transition = '';
                }
            }

            function setTranslate(xPos, yPos, el) {
                el.style.transform = `translate(${xPos}px, ${yPos}px)`;
            }
        }

        // Setup canvas panning
        function setupCanvasPanning() {
            let isPanningCanvas = false;
            let startX = 0;
            let startY = 0;
            let scrollLeft = 0;
            let scrollTop = 0;

            canvas.addEventListener('mousedown', (e) => {
                if (e.target === canvas || e.target.id === 'canvas') {
                    isPanningCanvas = true;
                    canvas.style.cursor = 'grabbing';
                    
                    startX = e.clientX;
                    startY = e.clientY;
                    scrollLeft = panOffset.x;
                    scrollTop = panOffset.y;
                    
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanningCanvas) return;
                
                e.preventDefault();
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                panOffset.x = scrollLeft + dx;
                panOffset.y = scrollTop + dy;
                
                updateCanvasTransform();
            });

            document.addEventListener('mouseup', () => {
                if (isPanningCanvas) {
                    isPanningCanvas = false;
                    canvas.style.cursor = 'grab';
                }
            });

            document.addEventListener('mouseleave', () => {
                if (isPanningCanvas) {
                    isPanningCanvas = false;
                    canvas.style.cursor = 'grab';
                }
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.min(Math.max(zoomLevel * delta, 0.3), 3);
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const zoomRatio = newZoom / zoomLevel;
                panOffset.x = mouseX - (mouseX - panOffset.x) * zoomRatio;
                panOffset.y = mouseY - (mouseY - panOffset.y) * zoomRatio;
                
                zoomLevel = newZoom;
                updateCanvasTransform();
            }, { passive: false });
        }

        // Loading screen
        function showLoading(text = 'Loading...') {
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('loadingText').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && activeNode) {
                clearActiveSelection();
            }
        });
    </script>
</body>
</html>
